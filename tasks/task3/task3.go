package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

/*
Дана последовательность чисел: 2,4,6,8,10. Найти сумму их квадратов(22+32+42….) с использованием конкурентных вычислений.

В этот раз мы должны получить сумму, общий алгоритм остается таким же как предыдущий, но встает проблема синхронизации доступа к значению суммы. Так как прибавление к числу не является атомарной операцией,
и под капотом производится в несколько действий, то две горутины могут начать прибавлять вычисленное в них число к одному и тому же значению, тем самым одна перезапишет значение другой и итоговая сумма получится неправильной
Для синхронизаиции данных можно использовать либо Mutex'ы, которые будут блокировать ресурс другим горутинам, либо atomic'и, которые позволяют производить операции по типу сложения - атомарного и избегать гонки данных.
Мне захотелось использовать именно второй подход
Также, это можно сделать используя каналы, потому что канал также может выступать в качестве примитива синхронизации и с точки зрения создателей языка Го, такой подход является более идеоматическим


*/

func Pow(sum *int64, a int, wg *sync.WaitGroup) {
	defer wg.Done()
	atomic.AddInt64(sum, int64(a*a))
}

func main() {

	data := []int{2, 4, 6, 8, 10}
	var sum int64
	wg := &sync.WaitGroup{}
	wg.Add(len(data))
	for _, v := range data {
		Pow(&sum, v, wg)
	}
	wg.Wait()
	fmt.Println(sum)
}
